<!DOCTYPE html>
<html lang=zh>
<head>
    <meta charset="utf-8">
    
    <title>Mix&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta property="og:type" content="website">
<meta property="og:title" content="Mix&#39;s Blog">
<meta property="og:url" content="http://mix.h2life.cn/index.html">
<meta property="og:site_name" content="Mix&#39;s Blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mix&#39;s Blog">
    

    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">Mix&#39;s Blog</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">主页</a>
                
                    <a class="main-nav-link" href="/archives">归档</a>
                
                    <a class="main-nav-link" href="/categories">分组</a>
                
                    <a class="main-nav-link" href="/tags">标签</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/avatar.png" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">主页</a></td>
                
                    <td><a class="main-nav-link" href="/archives">归档</a></td>
                
                    <td><a class="main-nav-link" href="/categories">分组</a></td>
                
                    <td><a class="main-nav-link" href="/tags">标签</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/avatar.png" />
            <h2 id="name">Mix</h2>
            <h3 id="title">记录也是一种生活方式</h3>
            <span id="location"><i class="fa fa-map-marker"></i>武汉, 中国</span>
            <a id="follow" target="_blank" href="https://github.com/h2mix">关注我</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                1
                <span>文章</span>
            </div>
            <div class="article-info-block">
                1
                <span>标签</span>
            </div>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-Kotlin进阶之路-函数" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/04/17/Kotlin进阶之路-函数/">Kotlin进阶之路-函数</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/04/17/Kotlin进阶之路-函数/">
            <time datetime="2018-04-17T00:52:00.507Z" itemprop="datePublished">2018-04-17</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/kotlin-Language/">kotlin Language</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/kotlin-Language/">kotlin Language</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>2017年，谷歌将Kotlin作为了Android的一级开发语言，与Java相比，Kotlin语法简洁，高效，最重要的是，Kotlin能与Java完全互通，工具支持上也极度友好，Java的常用IDE也可以用来完美的编写Kotlin代码，kotlin已经引入相对多的项目，以后也会有更好的发展。</p>
<p>由于编程语言基本都是互通的，掌握一门语言后学习另外一门编程语言也相对容易，所以掌握Kotlin的基础语法是很容易的,本文假设读者拥有一定的Kotlin基础，用探讨的方式描述Kotlin函数，以及Kotlin函数是如何优雅的完成Java问题的。</p>
<p>在Kotkin中，函数是一等公民（对象），事实上，Kotlin是一切皆对象的，函数可以与普通对象一样，在使用过程中被传递。</p>
<h2 id="1-普通函数-Java有的我都有"><a href="#1-普通函数-Java有的我都有" class="headerlink" title="1.普通函数-Java有的我都有"></a>1.普通函数-Java有的我都有</h2><p>函数的声明方式</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">funname</span><span class="params">(arg0:<span class="type">Type1</span>,arg1:<span class="type">Type2</span>,...)</span></span>:returnType&#123;</span><br><span class="line">  <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当返回类型为Unit（默认类型，没有返回值），则可以省略，否则一定需要指明类型，如下函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">(b: <span class="type">Array</span>&lt;<span class="type">Byte</span>&gt;, off: <span class="type">Int</span> = <span class="number">0</span>, len: <span class="type">Int</span> = b.size)</span></span> &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例函数描述了一个Kotlin基本函数的样子，定义简单，同时可以指定默认值，函数参数的默认值甚至可以从另外一个参数获取，如<code>b.size</code>,该函数怎么调用呢？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read(array,[可选])</span><br></pre></td></tr></table></figure>
<p>或指定参数名称调用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read(b = array,[可选])</span><br></pre></td></tr></table></figure>
<p>kotlin使函数的功能更加强大，使用起来也简单了很多。</p>
<p>另外，kotlin也支持可变参函数，java中的…,如</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(<span class="keyword">vararg</span> strings: <span class="type">String</span>)</span></span> &#123; <span class="comment">/* …… */</span> &#125;</span><br><span class="line"></span><br><span class="line">foo(strings = *arrayOf(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>))</span><br></pre></td></tr></table></figure>
<p>值得注意的是这个 * 号，他将数组转化为可变参数传递，最后，将普通函数再完善一下。</p>
<p>如单表达式函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">double</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = x * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>泛型函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; &#123;</span><br><span class="line">    // ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展函数-给类加新衣"><a href="#扩展函数-给类加新衣" class="headerlink" title="扩展函数-给类加新衣"></a>扩展函数-给类加新衣</h2><p>扩展函数是Kotlin的一大特色之一，它提供的特性使我们很容易的扩展自己的类型，而无须使用继承和任何的设计模式</p>
<p>扩展函数的声明如下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> T.<span class="title">funName</span><span class="params">(arg0:<span class="type">Type1</span>,arg1:<span class="type">Type2</span>,...)</span></span>:returnType&#123;</span><br><span class="line">   <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如给Context扩展一个toast方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Context.<span class="title">toast</span><span class="params">(msg: <span class="type">String</span>, duration: <span class="type">Int</span> = Toast.LENGTH_SHORT)</span></span> = Toast.makeText(<span class="keyword">this</span>, msg, duration).show()</span><br></pre></td></tr></table></figure>
<p>然后使用Context的实例就可以调用了，如 <code>context.toast(&quot;Hello World&quot;)</code>.值得注意的是，kotlin的扩展函数只是让你能拿到被扩展类型实例的引用，即this指针，除了方便你调用之外，它实际与下面代码等同</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> ToastUtil&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">toast</span><span class="params">(context:<span class="type">Context</span>,msg: <span class="type">String</span>, duration: <span class="type">Int</span> =  Toast.LENGTH_SHORT)</span></span>&#123;</span><br><span class="line">    Toast.makeText(context, msg, duration).show()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用则变成 <code>ToastUtil.toast(...)</code>,这种方式也是Java中常用的，由于无法扩展，Java中通过创建一个静态单例类来作为工具类，这样的类通常有很多。</p>
<p>也就是说，即便toast是Contxet的扩展方法，它也无法操作该类的私有成员，它只是保持有与被扩展类型的联系，这种联系在kotlin编译中关联起来，上面的扩展函数编译生成如下的伪Java代码（通过反编译获取）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">toast</span><span class="params">(@NotNull Context $receiver, @NotNull String msg, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">        Intrinsics.checkParameterIsNotNull($receiver, <span class="string">"$receiver"</span>);</span><br><span class="line">        Intrinsics.checkParameterIsNotNull(msg, <span class="string">"msg"</span>);</span><br><span class="line">        Toast.makeText($receiver, msg, duration).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用则和工具类完全一致，这也是它Kotlin为简洁和特性做的努力，只不过这部分让编译器给做了。</p>
<p>扩展函数可以减少无关的工具类，比如给字符串加一个判断是不是数字的方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">isNaN</span><span class="params">()</span></span>:<span class="built_in">Boolean</span>&#123;</span><br><span class="line">   <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">"123456"</span>.isNaN())</span><br></pre></td></tr></table></figure>
<p>除了类型扩展，还需要说到伴生对象的扩展（companion object），伴生对象类似与其它语言的静态类，但不相同，它是一个真实的实例，而且是单例，我们依旧可以通过反编译的方式找到它生成的伪Java代码，它的存在形式是这样的，这里假设给Context添加了伴生对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Companion Companion = <span class="keyword">new</span> Companion();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Companion</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Token <span class="title">getToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//todo</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么说来，伴生对象与普通对象没有区别，但只在其定义的类中实例化，扩展伴生对象毫无问题。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> MyClass.Companion.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看似美妙的语法糖，是编译器精心酝酿的。</p>
<h2 id="函数传递-拒绝偏见，拥抱对象"><a href="#函数传递-拒绝偏见，拥抱对象" class="headerlink" title="函数传递-拒绝偏见，拥抱对象"></a>函数传递-拒绝偏见，拥抱对象</h2><p>在Kotlin中，函数也是对象，这意味着函数也可以像普通对象一样传递和返回，对于Java程序员来说，似乎很不可思议。但其实这种特性在众多的编程语言中随处可见。</p>
<p>这里举个简单的例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">(uid:<span class="type">String</span>,call:(<span class="type">result</span>:<span class="type">Result</span>)</span></span>-&gt;<span class="built_in">Unit</span>):()-&gt;<span class="built_in">Unit</span>&#123;</span><br><span class="line">    <span class="comment">// todo 执行网络请求，得到数据，封装成Result对象</span></span><br><span class="line">    <span class="comment">// 完成后执行 call(result) 返回数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> cancel = &#123;</span><br><span class="line">        <span class="comment">// todo 取消网络操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cancel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个从网络获取用户信息的简单封装，假设我们传入用户id就可以得到一些简要的信息，在函数体内，首先会根据输入信息做网络请求，得到数据后封装成Result对象，然后调用call(result)将结果传递给调用者，同时，根据函数的签名，还要返回一个函数，这个返回函数是干嘛的呢，在这里返回的是一个取消网络请求的函数，得到这个返回函数后，调用者随时可以取消这个网络请求。</p>
<p>该函数可以以如下方式调用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="keyword">val</span> cancel = getUserInfo(<span class="string">"123456"</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line"><span class="keyword">val</span> cancel = getUserInfo(<span class="string">"123456"</span>，&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种方式</span></span><br><span class="line"><span class="keyword">val</span> call = &#123;result:Result-&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> cancel = getUserInfo(<span class="string">"123456"</span>，call)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第四种方式</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">(result:<span class="type">Result</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> cancel = getUserInfo(<span class="string">"123456"</span>，::call)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//取消网络请求</span></span><br><span class="line">cancel()</span><br></pre></td></tr></table></figure>
<p>上面四种方式调用都是有效的，充分体现出Kotlin的灵活，注意第一种，当函数的最后参数是一个函数时，可以用方法一的书写方式，三四种则分别使用了lambda表达式和函数引用，如果函数的签名一致，就可以认为他们是相同的（忽略实现，只看声明），所以我们可以引用任何一个有相同签名（参数和返回值相同）的函数。</p>
<blockquote>
<p>只要它看起来像鸭子，叫起来像鸭子，它就是一只鸭子</p>
</blockquote>
<p>在面向对象中，函数并不是纯粹的，它会在类，继承中占有重要的作用，具有不同的外观，比如添加限定符之类的。</p>
<p>接下来，我们看一种特殊的函数传递</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.()</span></span> -&gt; <span class="built_in">Unit</span>): T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>inline关键字表示它是一个内联函数，内联函数用一句话解释就是编译器不生成该函数，而是把函数体拷贝到调用者的位置，这里简要说明一下，笔者主要要说的是<code>T.() -&gt; Unit</code>这种函数参数，从上文我们知道，这种扩展表示的是给某种具体类型扩展函数，函数里面的this会换掉成扩展类型的this，使用它的方式如下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">f2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">f3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> context = Context().apply &#123; </span><br><span class="line">            f1()</span><br><span class="line">            f2()</span><br><span class="line">            f3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能这样你觉得还是没什么用，现在把它用在Android里面</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sp = getSharedPreferences(<span class="string">"xx"</span>,Context.MODE_PRIVATE)</span><br><span class="line">sp.edit().apply &#123; </span><br><span class="line">            putString(<span class="string">"key"</span>,<span class="string">"value"</span>)</span><br><span class="line">            <span class="comment">//或者</span></span><br><span class="line">            <span class="keyword">this</span>.putString(<span class="string">"key"</span>,<span class="string">"value"</span>)</span><br><span class="line">            <span class="comment">//todo 继续添加其它字段</span></span><br><span class="line">&#125;.apply()</span><br></pre></td></tr></table></figure>
<p>是不是有一种一目了然的感觉。在kotllin中，除了apply，还有几个基本的内置函数，将在下文说到。</p>
<h2 id="run-、-apply-、-let-、-also-和-with"><a href="#run-、-apply-、-let-、-also-和-with" class="headerlink" title="run 、 apply 、 let 、 also 和 with"></a>run 、 apply 、 let 、 also 和 with</h2><p>这几个函数位于kotlin 包下的Standard.kt文件中，在定义和使用上颇为相似，下面比较一下他们的区别</p>
<p>1.run</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">run</span><span class="params">(block: ()</span></span> -&gt; R): R = block()  <span class="comment">//非扩展函数，任意地方调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.()</span></span> -&gt; R): R = block() <span class="comment">//扩展函数，对象方式调用</span></span><br></pre></td></tr></table></figure>
<p>说明：执行传入函数，返回传入函数执行结果</p>
<p>示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> say = <span class="string">"kotlin"</span>.run &#123; </span><br><span class="line">            <span class="string">"Hello kotlin"</span></span><br><span class="line">        &#125;</span><br><span class="line">println(say)  <span class="comment">//输出  "Hello kotlin"</span></span><br></pre></td></tr></table></figure>
<p>2.apply<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.()</span></span> -&gt; <span class="built_in">Unit</span>): T &#123; block(); <span class="keyword">return</span> <span class="keyword">this</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>说明：执行传入函数，返回调用者本身</p>
<p>示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> say = <span class="string">"kotlin"</span>.apply &#123; </span><br><span class="line">            <span class="keyword">this</span>.length</span><br><span class="line">        &#125;</span><br><span class="line">println(say)  <span class="comment">//输出  "kotlin"</span></span><br></pre></td></tr></table></figure>
<p>3.let<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>)</span></span> -&gt; R): R = block(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure></p>
<p>说明：执行传入函数，返回传入函数执行结果，与run不同的是，它的传入函数的参数需要传入调用者本身</p>
<p>示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> say = <span class="string">"kotlin"</span>.let &#123;s:String-&gt;</span><br><span class="line">           <span class="string">"Hello <span class="variable">$s</span>"</span></span><br><span class="line">        &#125;</span><br><span class="line">println(say)  <span class="comment">//输出  "Hello kotlin"</span></span><br></pre></td></tr></table></figure>
<p>4.also<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">also</span><span class="params">(block: (<span class="type">T</span>)</span></span> -&gt; <span class="built_in">Unit</span>): T &#123; block(<span class="keyword">this</span>); <span class="keyword">return</span> <span class="keyword">this</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>说明：执行传入函数，返回调用者本身，与apply不同的是，它的传入函数的参数需要传入调用者本身</p>
<p>示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> say = <span class="string">"kotlin"</span>.also &#123; s: String -&gt;</span><br><span class="line">            s.length</span><br><span class="line">        &#125;</span><br><span class="line">println(say) <span class="comment">//输出  "kotlin"</span></span><br></pre></td></tr></table></figure>
<p>5.also<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.()</span></span> -&gt; R): R = receiver.block()</span><br></pre></td></tr></table></figure></p>
<p>说明：传入对象和对象的扩展函数，调用对象执行扩展函数，并返回扩展函数执行的结果</p>
<p>示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> say = with(<span class="string">"kotlin"</span>)&#123;</span><br><span class="line">            <span class="comment">// this为kotlin</span></span><br><span class="line">            <span class="string">"Hello <span class="variable">$this</span>"</span></span><br><span class="line">        &#125;</span><br><span class="line">println(say)  <span class="comment">//输出  "Hello kotlin"</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于Kotlin函数的介绍到这里基本完成，事实上，还有一些函数特性没有说明，在后面的博文中，将继续加深各种函数的使用，建议读者阅读官方文档进行深入了解。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">


    <div class="bdsharebuttonbox">
    <a href="#" class="bds_more" data-cmd="more">分享到：</a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间">QQ空间</a>
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博">新浪微博</a>
    <a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博">腾讯微博</a>
    <a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网">人人网</a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信">微信</a>
</div>
<script>
window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"share":{"bdSize":16}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script>
<style>
    .bdshare_popup_box {
        border-radius: 4px;
        border: #e1e1e1 solid 1px;
    }
    .bdshare-button-style0-16 a,
    .bdshare-button-style0-16 .bds_more {
        padding-left: 20px;
        margin: 6px 10px 6px 0;
    }
    .bdshare_dialog_list a,
    .bdshare_popup_list a,
    .bdshare_popup_bottom a {
        font-family: 'Microsoft Yahei';
    }
    .bdshare_popup_top {
        display: none;
    }
    .bdshare_popup_bottom {
        height: auto;
        padding: 5px;
    }
</style>


</div>

            
    

        </footer>
    </div>
    
</article>


</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/04/17/Kotlin进阶之路-函数/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/kotlin-Language/">kotlin Language</a></p>
                            <p class="item-title"><a href="/2018/04/17/Kotlin进阶之路-函数/" class="title">Kotlin进阶之路-函数</a></p>
                            <p class="item-date"><time datetime="2018-04-17T00:52:00.507Z" itemprop="datePublished">2018-04-17</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">分类</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/kotlin-Language/">kotlin Language</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/kotlin-Language/">kotlin Language</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签云</h3>
        <div class="widget tagcloud">
            <a href="/tags/kotlin-Language/" style="font-size: 10px;">kotlin Language</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">链接</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2018 Mix<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        


    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>