{"meta":{"title":"Mix's Blog","subtitle":null,"description":null,"author":"Mix","url":"http://mix.h2life.cn"},"pages":[{"title":"Tags","date":"2018-04-27T09:05:38.369Z","updated":"2018-04-27T08:20:11.770Z","comments":true,"path":"tags/index.html","permalink":"http://mix.h2life.cn/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-04-27T09:06:01.368Z","updated":"2018-04-27T08:20:11.770Z","comments":true,"path":"categories/index.html","permalink":"http://mix.h2life.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Kotlin进阶之路-函数","slug":"Kotlin进阶之路-函数","date":"2018-04-17T00:52:00.507Z","updated":"2018-05-05T07:10:02.506Z","comments":true,"path":"2018/04/17/Kotlin进阶之路-函数/","link":"","permalink":"http://mix.h2life.cn/2018/04/17/Kotlin进阶之路-函数/","excerpt":"","text":"简介2017年，谷歌将Kotlin作为了Android的一级开发语言，与Java相比，Kotlin语法简洁，高效，最重要的是，Kotlin能与Java完全互通，工具支持上也极度友好，Java的常用IDE也可以用来完美的编写Kotlin代码，kotlin已经引入相对多的项目，以后也会有更好的发展。 由于编程语言基本都是互通的，掌握一门语言后学习另外一门编程语言也相对容易，所以掌握Kotlin的基础语法是很容易的,本文假设读者拥有一定的Kotlin基础，用探讨的方式描述Kotlin函数，以及Kotlin函数是如何优雅的完成Java问题的。 在Kotkin中，函数是一等公民（对象），事实上，Kotlin是一切皆对象的，函数可以与普通对象一样，在使用过程中被传递。 1.普通函数-Java有的我都有函数的声明方式 123fun funname(arg0:Type1,arg1:Type2,...):returnType&#123; //todo&#125; 当返回类型为Unit（默认类型，没有返回值），则可以省略，否则一定需要指明类型，如下函数 123fun read(b: Array&lt;Byte&gt;, off: Int = 0, len: Int = b.size) &#123; ……&#125; 示例函数描述了一个Kotlin基本函数的样子，定义简单，同时可以指定默认值，函数参数的默认值甚至可以从另外一个参数获取，如b.size,该函数怎么调用呢？ 1read(array,[可选]) 或指定参数名称调用 1read(b = array,[可选]) kotlin使函数的功能更加强大，使用起来也简单了很多。 另外，kotlin也支持可变参函数，java中的…,如 123fun foo(vararg strings: String) &#123; /* …… */ &#125;foo(strings = *arrayOf(\"a\", \"b\", \"c\")) 值得注意的是这个 * 号，他将数组转化为可变参数传递，最后，将普通函数再完善一下。 如单表达式函数 1fun double(x: Int): Int = x * 2 泛型函数 123fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; &#123; // ……&#125; 扩展函数-给类加新衣扩展函数是Kotlin的一大特色之一，它提供的特性使我们很容易的扩展自己的类型，而无须使用继承和任何的设计模式 扩展函数的声明如下 123fun T.funName(arg0:Type1,arg1:Type2,...):returnType&#123; //todo&#125; 如给Context扩展一个toast方法 1fun Context.toast(msg: String, duration: Int = Toast.LENGTH_SHORT) = Toast.makeText(this, msg, duration).show() 然后使用Context的实例就可以调用了，如 context.toast(&quot;Hello World&quot;).值得注意的是，kotlin的扩展函数只是让你能拿到被扩展类型实例的引用，即this指针，除了方便你调用之外，它实际与下面代码等同 12345object ToastUtil&#123; fun toast(context:Context,msg: String, duration: Int = Toast.LENGTH_SHORT)&#123; Toast.makeText(context, msg, duration).show() &#125;&#125; 调用则变成 ToastUtil.toast(...),这种方式也是Java中常用的，由于无法扩展，Java中通过创建一个静态单例类来作为工具类，这样的类通常有很多。 也就是说，即便toast是Contxet的扩展方法，它也无法操作该类的私有成员，它只是保持有与被扩展类型的联系，这种联系在kotlin编译中关联起来，上面的扩展函数编译生成如下的伪Java代码（通过反编译获取） 12345public static final void toast(@NotNull Context $receiver, @NotNull String msg, int duration) &#123; Intrinsics.checkParameterIsNotNull($receiver, \"$receiver\"); Intrinsics.checkParameterIsNotNull(msg, \"msg\"); Toast.makeText($receiver, msg, duration).show();&#125; 调用则和工具类完全一致，这也是它Kotlin为简洁和特性做的努力，只不过这部分让编译器给做了。 扩展函数可以减少无关的工具类，比如给字符串加一个判断是不是数字的方法 123456fun String.isNaN():Boolean&#123; //todo&#125;print(\"123456\".isNaN()) 除了类型扩展，还需要说到伴生对象的扩展（companion object），伴生对象类似与其它语言的静态类，但不相同，它是一个真实的实例，而且是单例，我们依旧可以通过反编译的方式找到它生成的伪Java代码，它的存在形式是这样的，这里假设给Context添加了伴生对象 123456789public final class Context &#123; public static final Companion Companion = new Companion(); public static final class Companion &#123; public final Token getToken() &#123; //todo &#125; &#125;&#125; 这么说来，伴生对象与普通对象没有区别，但只在其定义的类中实例化，扩展伴生对象毫无问题。 123fun MyClass.Companion.foo() &#123; // ……&#125; 看似美妙的语法糖，是编译器精心酝酿的。 函数传递-拒绝偏见，拥抱对象在Kotlin中，函数也是对象，这意味着函数也可以像普通对象一样传递和返回，对于Java程序员来说，似乎很不可思议。但其实这种特性在众多的编程语言中随处可见。 这里举个简单的例子 123456789fun getUserInfo(uid:String,call:(result:Result)-&gt;Unit):()-&gt;Unit&#123; // todo 执行网络请求，得到数据，封装成Result对象 // 完成后执行 call(result) 返回数据 val cancel = &#123; // todo 取消网络操作 &#125; return cancel&#125; 这是一个从网络获取用户信息的简单封装，假设我们传入用户id就可以得到一些简要的信息，在函数体内，首先会根据输入信息做网络请求，得到数据后封装成Result对象，然后调用call(result)将结果传递给调用者，同时，根据函数的签名，还要返回一个函数，这个返回函数是干嘛的呢，在这里返回的是一个取消网络请求的函数，得到这个返回函数后，调用者随时可以取消这个网络请求。 该函数可以以如下方式调用 123456789101112131415161718192021222324//第一种方式val cancel = getUserInfo(\"123456\")&#123;&#125;//第二种方式val cancel = getUserInfo(\"123456\"，&#123;&#125;)//第三种方式val call = &#123;result:Result-&gt;&#125;val cancel = getUserInfo(\"123456\"，call)//第四种方式fun call(result:Result)&#123;&#125;val cancel = getUserInfo(\"123456\"，::call)//取消网络请求cancel() 上面四种方式调用都是有效的，充分体现出Kotlin的灵活，注意第一种，当函数的最后参数是一个函数时，可以用方法一的书写方式，三四种则分别使用了lambda表达式和函数引用，如果函数的签名一致，就可以认为他们是相同的（忽略实现，只看声明），所以我们可以引用任何一个有相同签名（参数和返回值相同）的函数。 只要它看起来像鸭子，叫起来像鸭子，它就是一只鸭子 在面向对象中，函数并不是纯粹的，它会在类，继承中占有重要的作用，具有不同的外观，比如添加限定符之类的。 接下来，我们看一种特殊的函数传递 1234567public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; block() return this&#125; inline关键字表示它是一个内联函数，内联函数用一句话解释就是编译器不生成该函数，而是把函数体拷贝到调用者的位置，这里简要说明一下，笔者主要要说的是T.() -&gt; Unit这种函数参数，从上文我们知道，这种扩展表示的是给某种具体类型扩展函数，函数里面的this会换掉成扩展类型的this，使用它的方式如下 12345678910111213class Context&#123; fun f1()&#123;&#125; fun f2()&#123;&#125; fun f3()&#123;&#125;&#125;val context = Context().apply &#123; f1() f2() f3()&#125; 可能这样你觉得还是没什么用，现在把它用在Android里面 1234567val sp = getSharedPreferences(\"xx\",Context.MODE_PRIVATE)sp.edit().apply &#123; putString(\"key\",\"value\") //或者 this.putString(\"key\",\"value\") //todo 继续添加其它字段&#125;.apply() 是不是有一种一目了然的感觉。在kotllin中，除了apply，还有几个基本的内置函数，将在下文说到。 run 、 apply 、 let 、 also 和 with这几个函数位于kotlin 包下的Standard.kt文件中，在定义和使用上颇为相似，下面比较一下他们的区别 1.run 123public inline fun &lt;R&gt; run(block: () -&gt; R): R = block() //非扩展函数，任意地方调用public inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R = block() //扩展函数，对象方式调用 说明：执行传入函数，返回传入函数执行结果 示例： 1234val say = \"kotlin\".run &#123; \"Hello kotlin\" &#125;println(say) //输出 \"Hello kotlin\" 2.apply1public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; block(); return this &#125; 说明：执行传入函数，返回调用者本身 示例： 1234val say = \"kotlin\".apply &#123; this.length &#125;println(say) //输出 \"kotlin\" 3.let1public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R = block(this) 说明：执行传入函数，返回传入函数执行结果，与run不同的是，它的传入函数的参数需要传入调用者本身 示例： 1234val say = \"kotlin\".let &#123;s:String-&gt; \"Hello $s\" &#125;println(say) //输出 \"Hello kotlin\" 4.also1public inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T &#123; block(this); return this &#125; 说明：执行传入函数，返回调用者本身，与apply不同的是，它的传入函数的参数需要传入调用者本身 示例： 1234val say = \"kotlin\".also &#123; s: String -&gt; s.length &#125;println(say) //输出 \"kotlin\" 5.also1public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R = receiver.block() 说明：传入对象和对象的扩展函数，调用对象执行扩展函数，并返回扩展函数执行的结果 示例： 12345val say = with(\"kotlin\")&#123; // this为kotlin \"Hello $this\" &#125;println(say) //输出 \"Hello kotlin\" 总结关于Kotlin函数的介绍到这里基本完成，事实上，还有一些函数特性没有说明，在后面的博文中，将继续加深各种函数的使用，建议读者阅读官方文档进行深入了解。","categories":[{"name":"kotlin Language","slug":"kotlin-Language","permalink":"http://mix.h2life.cn/categories/kotlin-Language/"}],"tags":[{"name":"kotlin Language","slug":"kotlin-Language","permalink":"http://mix.h2life.cn/tags/kotlin-Language/"}]}]}